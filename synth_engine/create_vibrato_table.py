"""
Copyright 2021 Carl Georg Biermann

This file generates two lookup-tables used for uniform vibrato slopes.

The first table is used to map binary values to Scale5 values.
Since here we need a fast conversion, and we do not need the entire range,
using a LUT is a valid compromise here.

The second table contains the delays between consecutive Scale5 levels
for a linearly increasing modulation depth. This is to facilitate
a vibrato "ramp" that does not increase exponentially but linearly.

"""

import numpy as np

def scale5_byte_from_num(x):
    """
    Generates a Scale5 value.
    """
    return 16*((x-1) % 5) + (15 - (x-1) // 5)

def scale5_moddepth(x):
    """
    Computes the real modulation depth.
    """
    return 2**((x-1-15*5)/5)

min_amount = 28 # must be the same as MINIMAL_VIBRATO_DEPTH
max_amount = 54

# pitch (log)-space modulation depths
amounts = np.array(list(range(min_amount, max_amount+1)))



myfile = open("vibrato_lut.asm","w")
myfile.write("; This file was generated by running create_vibrato_table.py\n")
myfile.write("vibrato_scale5_lut:\n")
for a in amounts:
    myfile.write(f"   .byte ${scale5_byte_from_num(a):02x}\n")




# linear space modulation depths
depths = scale5_moddepth(amounts)

# the difference between the first two modulation depths marks the unit of measurement
# for depth increase per "tick"
smallstep = depths[1] - depths[0]

# express the modulation depths in terms of the step size
stepcounts = depths / smallstep

myfile.write("\nvibrato_delays_lut:\n")

for i in range(1,len(stepcounts)):
    myfile.write(f"   .byte {int(round(stepcounts[i]-stepcounts[0]))}\n")

myfile.close()
